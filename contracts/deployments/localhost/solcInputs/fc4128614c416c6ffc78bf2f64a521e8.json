{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/PaymentGateway.i.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IPaymentGateway {\n    /****\n     * @dev This struct describes represents the structure of a seller's wallet.\n     * @param validators The list of validators that can validate a withdraw.\n     * @param masterValidator this is the address of the wallet's creator.\n     * @param validationCount The total number of validation required to initiate a withdraw.\n     * @param balance The wallet balance.\n     */\n    struct Wallet {\n        address[] validators;\n        address masterValidator;\n        uint16 validationCount;\n        uint256 balance;\n        uint256 currentPendingTransaction;\n    }\n\n    struct ReturnedOrder {\n        uint256 price;\n        string productName;\n        string productId;\n        address client;\n        address walleAddress;\n    }\n\n    enum WalletTransactionStats {\n        COMPLETED,\n        ONGOING\n    }\n\n    struct PendingTransaction {\n        address recipient;\n        address[] validators;\n        uint256 amount;\n        WalletTransactionStats status;\n    }\n\n    /**\n     * @dev Get the seller's address\n     */\n    function getWallet(address wallet_address) external returns (Wallet memory);\n\n    /**\n     *@dev Get the seller's wallet balance\n     */\n    function getWalletBalance(\n        address wallet_address\n    ) external returns (uint256);\n\n    /**\n     *@dev This function is used to add a new validator to the seller's wallet\n     @param validator The address of the new validator \n     */\n    function addValidator(address validator) external returns (bool);\n\n    /**\n     *@dev Since the seller's wallet is a multi-signature wallet, this function is used to initiate\n           a transaction from the seller's wallet that all validators will have to validate\n     * @param amount The amount of money that validators are willing to withdraw.\n     * @param recipient The withdraw recipient.\n     */\n    function initiateTransaction(\n        uint256 amount,\n        address recipient\n    ) external returns (bool);\n\n    /**\n     * @dev This function is used to create a new seller's wallet.\n     * @param validators The list of validators that can validate a pending transaction.\n     * @param validationCount The total number of validation required to process a transaction.\n     */\n    function createWallet(\n        address[] memory validators,\n        uint16 validationCount\n    ) external returns (bool);\n\n    function validateTransaction(\n        address walletAddress,\n        uint256 transactionIndex\n    ) external returns (bool);\n\n    /**\n     *\n     * @param productName Name of the product that the user is buying.\n     * @param productId The web2 product id.\n     * @param price The price of the ordered product.s\n     * @param walletAddress Seller's wallet address\n     */\n    function placeOrder(\n        string memory productName,\n        string memory productId,\n        uint256 price,\n        address walletAddress\n    ) external payable returns (bool);\n}\n"
    },
    "contracts/PaymentGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\nimport \"./interfaces/PaymentGateway.i.sol\";\n\n//========== ERRORS===========\n//=============================\nerror PayementGateway_DuplicatedValidators();\nerror PayementGateway_InvalidMasterValidators();\nerror PayementGateway_InvalidPriceSent();\nerror PayementGateway_WalletAlreadyCreated();\nerror PayementGateway_MasterValidatorShouldNotBeValidator();\nerror PayementGateway_InvalidValidators();\nerror PayementGateway_ShouldNotExceedMaximumValidatorsLength();\nerror PayementGateway_ValidatorsLengthShouldNoBeLessThanRequiredMinimum();\nerror PayementGateway_ValidationCountShouldNotExceedValidatorsLength();\nerror PayementGateway_ValidationCountShouldNotBeOneOrZero();\n\ncontract PaymentGateway is IPaymentGateway {\n    uint256 private immutable MINIMUM_WALLET_VALIDATORS;\n    uint256 private immutable MAXIMUM_WALLET_VALIDATORS;\n\n    mapping(address => Wallet) s_wallet;\n    mapping(address => mapping(uint256 => PendingTransaction))\n        private s_pendingTransactions;\n\n    event AddValidator(address indexed validator);\n\n    event Order(\n        uint256 price,\n        uint256 transactionValueProof,\n        string productName,\n        string productId,\n        address indexed indexedClientAddress,\n        address indexed indexedSellerAddress,\n        address  clientAddress,\n        address  sellerAddress\n    );\n\n    event CompletedTransaction(\n        address indexed walletAddress,\n        uint256 amount,\n        uint256 transactionIndex,\n        address indexed recipientAddress\n    );\n\n    event CreateWallet(address walletAddress, address[] validators);\n\n    modifier IsNotMasterValidator(address sender) {\n        if (sender != s_wallet[sender].masterValidator) {\n            revert PayementGateway_InvalidMasterValidators();\n        }\n        _;\n    }\n\n    modifier IsWalletAlreadyCreated(address wallet_address) {\n        if (s_wallet[wallet_address].validationCount > 0) {}\n        _;\n    }\n\n    modifier IsValidator(address validator, address walletAddress) {\n        address[] memory validators = s_wallet[walletAddress].validators;\n        bool isValidator;\n\n        for (uint index = 0; index < validators.length; index++) {\n            if (validators[index] == validator) {\n                isValidator = true;\n            }\n        }\n\n        require(isValidator == true, \"Milicious validator\");\n        _;\n    }\n\n    constructor(\n        uint256 minimum_wallet_validators,\n        uint256 maximum_wallet_validators\n    ) {\n        MINIMUM_WALLET_VALIDATORS = minimum_wallet_validators;\n        MAXIMUM_WALLET_VALIDATORS = maximum_wallet_validators;\n    }\n\n    function getWallet(\n        address wallet_address\n    ) external view returns (Wallet memory) {\n        return s_wallet[wallet_address];\n    }\n\n    function getWalletBalance(\n        address wallet_address\n    ) external view returns (uint256) {\n        return s_wallet[wallet_address].balance;\n    }\n\n    function addValidator(\n        address validator\n    ) external IsNotMasterValidator(msg.sender) returns (bool) {\n        s_wallet[msg.sender].validators.push(validator);\n        emit AddValidator(validator);\n        return true;\n    }\n\n    function createWallet(\n        address[] memory validators,\n        uint16 validationCount\n    ) external IsWalletAlreadyCreated(msg.sender) returns (bool) {\n        require(\n            s_wallet[msg.sender].validators.length < 1,\n            \"Wallet already created\"\n        );\n\n        if (validators.length + 1 > MAXIMUM_WALLET_VALIDATORS) {\n            revert PayementGateway_ShouldNotExceedMaximumValidatorsLength();\n        } else if (validators.length + 1 < MINIMUM_WALLET_VALIDATORS) {\n            revert PayementGateway_ValidatorsLengthShouldNoBeLessThanRequiredMinimum();\n        } else if (validationCount > validators.length + 1) {\n            revert PayementGateway_ValidationCountShouldNotExceedValidatorsLength();\n        } else if (validationCount <= 1) {\n            revert PayementGateway_ValidationCountShouldNotBeOneOrZero();\n        }\n\n        s_wallet[msg.sender] = Wallet({\n            balance: 0,\n            masterValidator: msg.sender,\n            validationCount: validationCount,\n            validators: new address[](0),\n            currentPendingTransaction: 0\n        });\n\n        for (uint i = 0; i < validators.length; i++) {\n            //Wallte msg.sender should not be among validators\n            if (validators[i] == msg.sender) {\n                revert PayementGateway_MasterValidatorShouldNotBeValidator();\n            }\n\n            //Check for duplicated validators\n            for (uint index = 0; index < validators.length; index++) {\n                if (validators[index] == validators[i] && i != index) {\n                    revert PayementGateway_DuplicatedValidators();\n                }\n            }\n            s_wallet[msg.sender].validators.push(validators[i]);\n        }\n\n        emit CreateWallet(msg.sender, validators);\n        return true;\n    }\n\n    function initiateTransaction(\n        uint256 amount,\n        address recipient\n    ) external returns (bool) {\n        Wallet memory wallet = s_wallet[msg.sender];\n\n        require(amount > 0, \"Transaction amout can't be 0\");\n        require(wallet.balance >= amount, \"Invalid balance\");\n        require(wallet.validators[0] != address(0), \"Wallet not created\");\n\n        uint256 newTransactionIndex = ++s_wallet[msg.sender]\n            .currentPendingTransaction;\n\n        s_pendingTransactions[msg.sender][\n            newTransactionIndex\n        ] = PendingTransaction({\n            validators: new address[](0),\n            amount: amount,\n            recipient: recipient,\n            status: WalletTransactionStats.ONGOING\n        });\n        return true;\n    }\n\n    function validateTransaction(\n        address walletAddress,\n        uint256 transactionIndex\n    ) external IsValidator(msg.sender, walletAddress) returns (bool) {\n        PendingTransaction memory transaction = s_pendingTransactions[\n            walletAddress\n        ][transactionIndex];\n\n        for (uint index = 0; index < transaction.validators.length; index++) {\n            require(\n                transaction.validators[index] != msg.sender,\n                \"Already participated\"\n            );\n        }\n\n        s_pendingTransactions[walletAddress][transactionIndex].validators.push(\n            msg.sender\n        );\n\n        if (\n            s_pendingTransactions[walletAddress][transactionIndex]\n                .validators\n                .length +\n                1 >=\n            s_wallet[walletAddress].validationCount\n        ) {\n            (bool success, ) = transaction.recipient.call{\n                value: transaction.amount\n            }(\"\");\n\n            require(success, \"Failed to process the transaction\");\n        }\n\n        return true;\n    }\n\n    function placeOrder(\n        string memory productName,\n        string memory productId,\n        uint256 price,\n        address walletAddress\n    ) external payable returns(bool ) {\n        require(msg.value >= price, \"Invalid amount\");\n        s_wallet[walletAddress].balance += msg.value;\n        uint256 value = msg.value;\n\n        emit Order(\n            price,\n            value,\n            productName,\n            productId,\n            walletAddress,\n            msg.sender,\n            msg.sender,\n            walletAddress\n        );\n        \n        return true;\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}